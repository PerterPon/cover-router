// Generated by CoffeeScript 1.9.0
"use strict";
var create, matchMethod, matchPath, methods, pathToRegexp, urlLib,
  __slice = [].slice;

methods = require('methods');

pathToRegexp = require('./path-to-regexp');

urlLib = require('url');

matchMethod = function(req, requiredMethod) {
  var method;
  method = req.method;
  if (requiredMethod == null) {
    return true;
  }
  if (method === requiredMethod) {
    return true;
  }
  if ('HEAD' === requiredMethod && 'GET' === method) {
    return true;
  }
  return false;
};

matchPath = function(req, re, reqParams, source) {
  var args, idx, m, method, nPathname, name, originalUrl, params, pathItem, pathname, sourceItem, sourceUrlItem, url, urlInfo, _i, _j, _len, _len1;
  url = req.url, originalUrl = req.originalUrl, method = req.method;
  if (originalUrl == null) {
    req.originalUrl = url;
  }
  if (originalUrl == null) {
    originalUrl = url;
  }
  urlInfo = urlLib.parse(originalUrl);
  pathname = urlInfo.pathname;
  if (m = re.exec(pathname)) {
    args = m.slice(1).map(function(val) {
      if (val != null) {
        return decodeURIComponent(val);
      }
    });
    req.originatorParam = args;
    if (null !== reqParams) {
      params = {};
      for (idx = _i = 0, _len = reqParams.length; _i < _len; idx = ++_i) {
        name = reqParams[idx];
        params[name] = args[idx];
      }
      req.params = params;
    }
    if (0 === pathname.indexOf(source)) {
      pathItem = pathname.split('/');
      sourceItem = source.split('/');
      for (idx = _j = 0, _len1 = sourceItem.length; _j < _len1; idx = ++_j) {
        sourceUrlItem = sourceItem[idx];
        if (sourceUrlItem === pathItem[0]) {
          pathItem.shift();
        } else {
          break;
        }
      }
      pathItem.unshift('');
      nPathname = pathItem.join('/');
      if (!nPathname) {
        nPathname = '/';
      }
      urlInfo.pathname = nPathname;
      req.url = urlLib.format(urlInfo);
      if (req.url == null) {
        req.url = '';
      }
      if ('' === req.url.trim()) {
        req.url = '/';
      }
    }
    return true;
  } else {
    return false;
  }
};

create = function(method) {
  if (method != null) {
    method = method.toUpperCase();
  }
  return function(path, fn, opt) {
    var re, reqParams, source;
    source = path;
    if ('\/' === path[path.length - 1]) {
      path = path.substr(0, path.length - 1);
    }
    re = pathToRegexp(path, opt);
    reqParams = path.match(/\:\w+\/?/g);
    if (null !== reqParams) {
      reqParams = reqParams.map(function(val) {
        var bb, ff;
        ff = 0;
        bb = val.length;
        if (0 === val.indexOf('\/\:')) {
          ff = 2;
        } else if (0 === val.indexOf('\:')) {
          ff = 1;
        }
        if (val.length - 1 === val.lastIndexOf('\/')) {
          bb -= 1;
        }
        return val.substring(ff, bb);
      });
    }
    if ('GeneratorFunction' === fn.constructor.name) {
      return function*() {
        var args, next, req, _i;
        args = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), next = arguments[_i++];
        req = (this || {}).req;
        if (req == null) {
          req = args[0];
        }
        if (!matchMethod(req, method)) {
          return (yield next);
        }
        args.push(next);
        if (true === matchPath(req, re, reqParams, source)) {
          (yield fn.apply(this, args));
          return;
        }
        return (yield next);
      };
    } else {
      return function(req, res, next) {
        if (!matchMethod(req, method)) {
          return next();
        }
        if (true === matchPath(req, re, reqParams, source)) {
          fn(req, res, next);
          return;
        }
        return next();
      };
    }
  };
};

methods.forEach(function(method) {
  return exports[method] = create(method);
});

exports.all = create();
